---
layout:     post
title:      "Leetcode Stack类型整理 part01"
subtitle:   " \"Python Leetcode整理\""
date:       2020-09-14 12:00:00
author:     "TonyXu"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Python
    - Leetcode
    - Algorithm
---

### 389. Find the Difference

Given two strings s and t which consist of only lowercase letters.

String t is generated by random shuffling string s and then add one more letter at a random position.

Find the letter that was added in t.

### Example:
```
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.

```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        s=sorted(list(s))
        t=sorted(list(t))

        for i in range(len(s)):
            if s[i]!=t[i]:
                return t[i]
        else:
            return t[-1]
```

### 方法二

时间复杂度：O(n)

空间复杂度：O(n)

```
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        counts = collections.Counter(s)
        countt = collections.Counter(t)
        for i in countt:
            if i not in counts or counts[i] != countt[i]:
                return i
```

## 136. Single Number

Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

### Example 1:

```
Input: [2,2,1]
Output: 1
```

### Example 2:
```
Input: [4,1,2,1,2]
Output: 4
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        count = collections.Counter(nums)
        for i in count:
            if count[i] == 1:
                return i
```

## 318. Maximum Product of Word Lengths

Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.

### Example 1:

```
Input: ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".
```

### Example 2:

```
Input: ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".
```

### Example 3:
```
Input: ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
```

### 方法一

时间复杂度：O(n^2)

空间复杂度：O(n)

```
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        ws = [[set(w), len(w)] for w in words]
        res = 0
        for i in range(len(ws)):
            for j in range(i, len(ws)):
                if not ws[i][0]&ws[j][0] and ws[i][1]*ws[j][1] > res:
                    res = ws[i][1]*ws[j][1]
        return res
```

## 201. Bitwise AND of Numbers Range

Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

### Example 1:

```
Input: [5,7]
Output: 4
```

### Example 2:
```
Input: [0,1]
Output: 0
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        t = 0   
        while m < n:
            m = m >> 1
            n = n >> 1
            t += 1
        return m << t
```

## 338. Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

### Example 1:
```
Input: 2
Output: [0,1,1]
```

### Example 2:
```
Input: 5
Output: [0,1,1,2,1,2]
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(n)

```
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = [0 for _ in range(num+1)]
        for i in range(1, num+1):
            if(i%2 == 1):
                res[i] = res[i-1]+1
            else:
                res[i] = res[i//2]
        return res
```

## 89. Gray Code

The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

### Example 1:

```
Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1
```

### Example 2:

```
Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def grayCode(self, n: int) -> List[int]:
        if n == 0:
            return [0]
        res = []
        def back(code, x):
            if len(code) == n:
                res.append(int(code, 2))
            elif x == 0:
                back(code+'0', 0)
                back(code+'1', 1)
            else:
                back(code+'1', 0)
                back(code+'0', 1)
        back('', 0)
        return res
```

## 268. Missing Number

Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

### Example 1:

```
Input: [3,0,1]
Output: 2
```

### Example 2:
```
Input: [9,6,4,2,3,5,7,0,1]
Output: 8
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        for i in range(len(nums)+2):
            if i not in nums:
                return i
```

## 191. Number of 1 Bits

Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).


### Example 1:

```
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
```

### Example 2:

```
Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
```

### Example 3:
```
Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def hammingWeight(self, n: int) -> int:
        lst = [int(i) for i in str(bin(n))[2:]]
        return sum(lst)
```

## 190. Reverse Bits

Reverse bits of a given 32 bits unsigned integer.


### Example 1:

```
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
```

### Example 2:
```
Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
```

### 方法一

时间复杂度：O(n)

空间复杂度：O(1)

```
class Solution:
    def reverseBits(self, n: int) -> int:
        return int("0b"+("0"*32+bin(n)[2:])[-32:][::-1], base=2)
```
